/*  
    Day 5 – Palindrome Linked List (LeetCode 234)

    Approach Used:
    Two-Pointer + Reverse Second Half
    ----------------------------------
    1) Use fast & slow pointers to find the middle of the linked list.
       - fast moves 2 steps, slow moves 1 step.
       - When fast reaches end, slow is at midpoint.
    2) If length is odd → skip the middle node.
    3) Reverse the second half of the linked list.
    4) Compare first half and reversed second half node by node.
    5) If all values match → palindrome.

    Why this works:
    - We never modify the first half.
    - Reversing second half allows symmetric comparison.

    Time Complexity: O(n)
    Space Complexity: O(1)

    How to Run:
    g++ PalindromeLinkedList.cpp -o run
    ./run
*/

#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true;

        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        if (fast) slow = slow->next;

        ListNode* prev = nullptr;
        while (slow) {
            ListNode* nxt = slow->next;
            slow->next = prev;
            prev = slow;
            slow = nxt;
        }

        ListNode *p = head, *q = prev;
        while (q) {
            if (p->val != q->val) return false;
            p = p->next;
            q = q->next;
        }
        return true;
    }
};

// Simple test
int main() {
    // Creating linked list: 1 -> 2 -> 2 -> 1
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(2);
    head->next->next->next = new ListNode(1);

    Solution obj;
    cout << "Is Palindrome: " << (obj.isPalindrome(head) ? "true" : "false") << endl;
    return 0;
}
